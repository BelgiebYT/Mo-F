package com.belgieyt.morefeatures.blocks;

import com.belgieyt.morefeatures.init.ModTileEntityTypes;
import com.belgieyt.morefeatures.init.StatsInit;
import com.belgieyt.morefeatures.tileentity.ItemHolderTileentity;
import net.minecraft.block.*;
import net.minecraft.entity.player.PlayerEntity;
import net.minecraft.entity.player.ServerPlayerEntity;
import net.minecraft.inventory.InventoryHelper;
import net.minecraft.pathfinding.PathType;
import net.minecraft.tileentity.*;
import net.minecraft.util.*;
import net.minecraft.util.math.BlockPos;
import net.minecraft.util.math.BlockRayTraceResult;
import net.minecraft.util.math.shapes.IBooleanFunction;
import net.minecraft.util.math.shapes.ISelectionContext;
import net.minecraft.util.math.shapes.VoxelShape;
import net.minecraft.util.math.shapes.VoxelShapes;
import net.minecraft.world.IBlockReader;
import net.minecraft.world.World;
import net.minecraftforge.fml.network.NetworkHooks;

import java.util.stream.Stream;

public class ItemHolderBlock extends Block {

        public ItemHolderBlock(Block.Properties properties) {
    super(properties);
}

        /*
         * We override this method to tell the game that this block contains a tile
         * entity.
         */
        @Override
        public boolean hasTileEntity(BlockState state) {
            return true;
        }

        /*
         * This method creates the tile entity for this block using our field in
         * ModTileEntityTypes.
         */
        @Override
        public TileEntity createTileEntity(BlockState state, IBlockReader world) {
            return ModTileEntityTypes.ITEM_HOLDER.get().create();
        }

        /*
         * This method is called when the player right clicks this block. We first check
         * that it is happening server side. We then grab the tile entity from the
         * position. We then check that the tile entity is our tile entity, and not some
         * random tile. And if it is, we open the gui for the server player and return
         * ActionResultType.SUCCESS, which allows it to play the arm swing animation.
         * Else we are returning ActionResultType.FAIL so it does not play the swing
         * animation.
         */
        @Override
        public ActionResultType onBlockActivated(BlockState state, World worldIn, BlockPos pos, PlayerEntity player,
                                                 Hand handIn, BlockRayTraceResult hit) {
            if (!worldIn.isRemote) {
                final TileEntity tile = worldIn.getTileEntity(pos);
                if (tile instanceof ItemHolderTileentity) {
                    NetworkHooks.openGui((ServerPlayerEntity) player, (ItemHolderTileentity) tile, pos);
                    player.addStat(StatsInit.INSPECT_ITEM_PLINTHS);
                    return ActionResultType.SUCCESS;
                }
            }
            return ActionResultType.FAIL;
        }

        /*
         * This method is called when the block is replaced by another block. In here we
         * check that the block is not replaced by the same block. Then we proceed to
         * get the tile entity at that position and check if it is our tile. If it is,
         * we use the dropItems utility method in InventoryHelper to drop the tile
         * entity's item contents.
         */
        @Override
        public void onReplaced(BlockState state, World worldIn, BlockPos pos, BlockState newState, boolean isMoving) {
            if (state.getBlock() != newState.getBlock()) {
                TileEntity tile = worldIn.getTileEntity(pos);
                if (tile instanceof ItemHolderTileentity) {
                    InventoryHelper.dropItems(worldIn, pos, ((ItemHolderTileentity) tile).getItems());
                }
            }
        }

        /*
         * This method gets the shape of the block that is used for rendering, collision
         * and hitbox. This was generated by the BlockBench Voxel Shape Plugin.
         */
        @Override
        public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context) {
            return Stream.of(Block.makeCuboidShape(3, 2, 3, 13, 15, 13), Block.makeCuboidShape(2, 15, 2, 14, 16, 14),
                    Block.makeCuboidShape(0, 0, 0, 16, 2, 16)).reduce((v1, v2) -> {
                return VoxelShapes.combineAndSimplify(v1, v2, IBooleanFunction.OR);
            }).get();
        }
        public boolean allowsMovement(BlockState state, IBlockReader worldIn, BlockPos pos, PathType type) {
            return true;
        }
}
